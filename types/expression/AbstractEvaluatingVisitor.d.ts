import { ParserRuleContext } from 'antlr4';
import AttributedObject from './AttributedObject';
import Evaluator from './Evaluator';
import Function from './functions/Function';
import EvaluationEnvironment from './EvaluationEnvironment';
declare const AggregateExpressionVisitor: any;
export default class AbstractEvaluatingVisitor extends AggregateExpressionVisitor {
    static DEFAULT_FUNCTIONS: Map<string, Function>;
    private static __static_init;
    static _static_init(): void;
    private static registerDefaultFunction;
    protected top: number;
    private readonly stack;
    private evaluator;
    private environment;
    constructor(evaluator: Evaluator, environment: EvaluationEnvironment);
    protected set(delta: number, value: AttributedObject | null): void;
    getResult(): any;
    protected get(delta: number): AttributedObject | null;
    visitCompilationUnit(ctx: ParserRuleContext): AttributedObject | null;
    visitLogicalAndNode(ctx: ParserRuleContext): any;
    visitBitwiseOrNode(ctx: ParserRuleContext): any;
    visitBitwiseXorNode(ctx: ParserRuleContext): any;
    visitNENode(ctx: ParserRuleContext): any;
    visitConditionalNode(ctx: ParserRuleContext): any;
    visitModNode(ctx: ParserRuleContext): any;
    visitLogicalNotNode(ctx: ParserRuleContext): any;
    visitEQNode(ctx: ParserRuleContext): any;
    visitBitwiseAndNode(ctx: ParserRuleContext): any;
    visitGENode(ctx: ParserRuleContext): any;
    visitUnsignedRightShiftNode(ctx: ParserRuleContext): any;
    visitAddNode(ctx: ParserRuleContext): any;
    visitLTNode(ctx: ParserRuleContext): any;
    visitBitwiseNotNode(ctx: ParserRuleContext): any;
    visitSubtractNode(ctx: ParserRuleContext): any;
    visitGTNode(ctx: ParserRuleContext): any;
    visitValueReferenceNode(ctx: ParserRuleContext): any;
    visitRegexMatchNode(ctx: ParserRuleContext): any;
    visitLiteralExpression(ctx: ParserRuleContext): any;
    visitFunctionNode(ctx: ParserRuleContext): any;
    visitRightShiftNode(ctx: ParserRuleContext): any;
    visitDivNode(ctx: ParserRuleContext): any;
    visitLeftShiftNode(ctx: ParserRuleContext): any;
    visitExpressionNode(ctx: ParserRuleContext): any;
    visitLENode(ctx: ParserRuleContext): any;
    visitLogicalOrNode(ctx: ParserRuleContext): any;
    visitMulNode(ctx: ParserRuleContext): any;
    visitUnaryNode(ctx: ParserRuleContext): any;
    visitFunctionExpression(ctx: ParserRuleContext): any;
    visitValueReference(ctx: ParserRuleContext): any;
    visitLongConstNode(ctx: ParserRuleContext): any;
    visitFloatConstNode(ctx: ParserRuleContext): any;
    visitStringConstNode(ctx: ParserRuleContext): any;
    visitTrueNode(ctx: ParserRuleContext): any;
    visitFalseNode(ctx: ParserRuleContext): any;
    visitNullNode(ctx: ParserRuleContext): any;
    visitTerminal(ctx: ParserRuleContext): any;
    private visitBinaryOperators;
    private visitEqualityOperators;
}
export {};
